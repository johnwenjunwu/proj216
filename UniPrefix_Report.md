## Uni-Prefix Bitmap
(Team members.. @UCLA CS216)

### See what we've done in few lines!
IP prefix lookup is of great importance in routing. Currently, several fancy prefix lookup algorithms (e.g. Tree Bitmap, Multibit Trie) are widely used in many real-world scenarios. We came up with a modified algorithm on the basis of Multibit Trie and Lulea called **Uni-Prefix Bitmap** to acheive better performance (fewer nodes as well as shorter lookup time). 

We've implemented four different IP prefix lookup engines in JAVA: (pure) Multibit Trie, Uni-Prefix Multibit Trie, Tree Bitmap and Uni-Prefix Bitmap.
![](https://github.com/johnwenjunwu/proj216/blob/master/figures/FourSchemes.png?raw=true "Four Schemes")

We've run an experiment (strides = {8, 8, 8, 8}). Results are shown as below:

| Prefix Lookup Scheme | # Node  | Avg Node Size | Storage  | Prefixes we store |
| ------------- |:-----:|:--------------:|:-----:|:------:|
| Multibit Trie      | 25,349 | 1.6250 KB| 41,192 KB | 6N |
| Uni-Prefix Multibit Trie      | 4,049,552      |   0.8157 KB | 3,303,113 KB | 6N |
| Tree Bitmap | 31,815      | 0.1410 KB |  4,486 KB | N |
| Uni-Prefix Bitmap | 25,349      |  0.1417 KB | 3,592 KB | 6N |


## 1 Backgrounds
### Unibit Trie & Multibit Trie
A [unibit trie](https://raminaji.wordpress.com/unibit-tries/) is a tree in which each node is an array containing a 0-pointer and a 1-pointer, so it may make 32 accesses for a 32-bit prefix lookup. But [multibit trie](https://raminaji.wordpress.com/multibit-tries/) allows the number of indexing bits to change, by expanding the prefix length. Multibit trie searches faster at the cost of larger database size.
### Lulea
[Lulea](https://en.wikipedia.org/wiki/Lule%C3%A5_algorithm) is a multibit-trie scheme that uses fixed-stride trie nodes but uses bitmap compression to replace consecutive identical elements with a single value. A node bitmap (0 refers to removed positions) allows fast indexing on the compressed nodes.
### Tree Bitmap
Tree Bitmap ([eatherton2004tree](http://cseweb.ucsd.edu/~varghese/PAPERS/ccr2004.pdf)) is a high performance IP lookup algorithm. Each trie node (stride = s) has two bitmaps, one for data (internally stored prefiexes, (2^s - 1)-bit long) and one for pointers (external pointers, (2^s)-bit long), to compress these two kinds of information efficiently. 

![](https://github.com/johnwenjunwu/proj216/blob/master/figures/TreeBitmap.png?raw=true "TreeBitmap")

// TODO: new version of tree bitmap node figure

## 2 Uni-Prefix Design
The core of Uni-Prefix design is basically pushing the data (aka prefixes) to nodes in the next level to shrink the size of each node.
### 2.1 Uni-Prefix Multibit Trie 
- w/o pushback hack
    - The figure below shows the orginal optimization that we move the prefix to the next layer. In this case, we can reduce the size of each node to half, but will increase the memory access for each ip lookup by 1. ![alt text](https://github.com/johnwenjunwu/proj216/blob/master/figures/Uniprefix.png?raw=true "Original Uni-Prefix")
    - It turns out that we waste a lot storage at leaf nodes, since there is only one prefix without any pointer to other child nodes, which leads the our next optimization to reduce leaf nodes by pushing the prefix one layer back.
        
- W/ pushback hack
    - As shown in the figure below, we can push all the prefix at leaf node one layer up to replace the pointer. But we need one extra bit to note whether it's a pointer to the child node or a prefix, which can be put together with the 32-bit pointer or prefix. It allows 0 extra memory access when it's fetched with each item in the node. ![alt text](https://github.com/johnwenjunwu/proj216/blob/master/figures/UniprefixWithPushBack.png?raw=true "Original Uni-Prefix") 
    - After this modification, we can see that all the leaf nodes is a mixed storage with pointers and prefixes with 1 extra bit. The number of nodes are exactly same as multibit trie, but node's size is only the half of before. And also, the memory access for any ip lookup is same as before.

### 2.2 Uni-Prefix Bitmap
In order to avoid the obvious waste, we compress the pointers using bitmap over pointer array, which is pretty similar to the method used in Tree Bitmap. 
![alt text](https://github.com/johnwenjunwu/proj216/blob/master/figures/UniPrefixBitmap.png?raw=true "UniPrefixBitmap")

// TODO: new version of uniprefix bitmap node figure

One of the optimizations of Tree Bitmap to avoid obvious waste, **end node optimization**, need to be mentioned here. Trie nodes which are generated by prefixes like P8 in the figure below have bitmaps that are almost completely unused. Such nodes are defined as **null node**. The father of the node generated by P8 is regarded as **end node**, which can be encoded with a single extra bit per node. With the optimization illustrated in the right side of the figure below, the null node can be eliminated. Instead of storing pointers to null nodes, the end node actually stores the correspoding prefixes. Moreover, external bitmap for pointers to children nodes is no longer needed.
![alt text](https://github.com/johnwenjunwu/proj216/blob/master/figures/EndNodeOptimization.png?raw=true "end node optimization")

In Tree Bitmap, we can only shrink all **real null nodes**, whose father only has null children nodes. The **pseudo null nodes**, whose father has both null and non-null children nodes, however, have to be kept, because data and pointers are stored separately and cannot be compressed simultaneously. There is no such worry in Uni-Prefix Bitmap as it only compresses pointers while maintaining multiple copies of prefixes.
![alt text](https://github.com/johnwenjunwu/proj216/blob/master/figures/Real_vs_PseudoNullNode.png?raw=true "Real vs Pseudo Null Node")

Currently, each node in Uni-Prefix Bitmap has two bitmaps, one is over pointer array and one is to indicate the corresponding pointer is pointing to a prefix or a node.

## 3 Experiments, Results & Analysis
### Advantages of Uni-Preifx Bitmap
// TODO (zt)

### Disadvantages of Uni-Preifx Bitmap
Since we only use one bitmap to compress the pointers to the children, it's inevitable that we would store the same prefix for ultiple times (due to the prefix expanding). After careful calculation (under different testing data base), on average every prefix is stored for 6 times in trade of smaller node size. 

## 4 Conclusion
